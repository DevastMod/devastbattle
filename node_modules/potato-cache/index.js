'use strict'

const fs = require('fs')
const path = require('path')
const md5 = require('crypto-js/md5')
const CryptoJS = require('crypto-js')
const getFolderSize = require('get-folder-size')
const isJSON = require('validator/lib/isJSON')
const mkdirp = require('mkdirp')

exports = module.exports = function (path, secret, shouldMkdirp) {
  if (isType(path, 'string') && isType(secret, 'string')) {
    exports.cachePath = path
    exports.secretKey = secret
  }
  if (defaultFor(shouldMkdirp, true)) {
    fs.stat(path, (err) => {
      if(err) {
        mkdirp(path, console.log)
      }
    })
  }
  return exports
}

exports.write = function (key, data, callback) {
  if (isType(key, 'string') && isType(callback, 'function')) {
    fs.truncate(exports.getPath(key), 0, () => {
      var stream = fs.createWriteStream(exports.getPath(key), {encoding: 'utf-8'})
      stream.on('open', () => {
        stream.write(encrypt(data), (err) => {
          if (err) {
            onError(err)
          } else {
            callback(data)
          }
          stream.end()
        })
      })
      stream.on('error', onError)
    })
  }
}

exports.writeSync = (key, data) => {
  if(isType(key, 'string')) {
    try {
      fs.truncate(exports.getPath(key), 0, () => {
        var stream = fs.createWriteStream(exports.getPath(key), {encoding: 'utf-8'})
        stream.on('open', () => {
          stream.write(encrypt(data), (err) => {
            if (err) throw err
            stream.end()
          })
        })
        stream.on('error', onError)
      })
    } catch(err) {
      onError(err)
    }
  }
}

exports.read = (key, callback) => {
  if (isType(key, 'string') && isType(callback, 'function')) {
    var stream = fs.createReadStream(exports.getPath(key), {encoding: 'utf-8'})
    stream.once('readable', () => {
      callback(decrypt(stream.read()))
    })
    stream.on('error', onError)
  }
}

exports.readSync = (key) => {
  if (isType(key, 'string')) {
    try {
      let data = fs.readFileSync(exports.getPath(key))
      return decrypt(data)
    } catch(err) {
      onError(err)
    }
  }
}

exports.exists = (key) => {
  if (isType(key, 'string')) {
    return new Promise((resolve, reject) => {
      fs.stat(exports.getPath(key), (err, stat) => {
        if (!err) {
          resolve(stat)
        } else {
          reject(err)
        }
      })
    })
  }
}

exports.existsThenRead = (key) => {
  return new Promise((resolve, reject) => {
    exports.exists(key)
      .then(() => {
        exports.read(key, resolve)
      })
      .catch(reject)
  })
}

// maxAge in minutes
exports.isNotExpired = (key, maxAge) => {
  maxAge = defaultFor(maxAge, 180)
  if (isType(key, 'string') && isType(maxAge, 'number')) {
    return new Promise((resolve, reject) => {
      exports.exists(key)
        .then(stat => {
          let now = new Date().getTime()
          let endTime = new Date(stat.mtime).getTime()

          var diff = (now - endTime) / 1000 / 60

          if (maxAge > Math.abs(Math.round(diff))) {
            resolve()
          } else {
            reject(new Error('File is older than ' + maxAge + ' minutes'))
          }
        })
        .catch(reject)
    })
  }
}

exports.isNotExpiredThenRead = (key, maxAge) => {
  return new Promise((resolve, reject) => {
    exports.isNotExpired()
      .then(() => {
        exports.read(key, resolve)
      })
      .catch(reject)
  })
}

exports.getPath = (key) => {
  if (isType(key, 'string') && isType(exports.cachePath, 'string')) {
    return path.join(exports.cachePath, md5(key) + '.js')
  }
}

exports.purge = (key, callback) => {
  if (isType(key, 'string') && isType(callback, 'function')) {
    fs.unlink(exports.getPath(key), (err) => {
      if (!err) {
        callback()
      } else {
        onError(err)
      }
    })
  }
}

exports.purgeSync = (key) => {
  if (isType(key, 'string')) {
    try {
      return fs.unlinkSync(exports.getPath(key))
    } catch(err) {
      onError(err)
    }
  }
}

exports.trash = (callback) => {
  if (isType(callback, 'function')) {
    fs.readdir(exports.cachePath, (err, files) => {
      if (!err) {
        files.forEach(file => fs.unlinkSync(path.join(exports.cachePath, file)))
        callback()
      } else {
        onError(err)
      }
    })
  }
}

exports.trashSync = () => {
  exports.trash(() => {})
}

/**
 * Takes in a promise, and upon success it resolves the folder size in megabytes, otherwise it rejects the error
 */
exports.getSize = (callback) => {
  if (isType(callback, 'function')) {
    getFolderSize(exports.cachePath, (err, size) => {
      if (!err) {
        callback((size / 1024 / 1024).toFixed(3))
      } else {
        onError(err)
      }
    })
  }
}

function encrypt (data) {
  if(typeof data === 'object') {
    data = JSON.stringify(data)
  }
  let encData = CryptoJS.AES.encrypt(data, exports.secretKey)

  return encData.toString()
}

function decrypt(data) {
  let decBytes = CryptoJS.AES.decrypt(data.toString(), exports.secretKey)
  let decData = decBytes.toString(CryptoJS.enc.Utf8)

  return isJSON(decData) ? JSON.parse(decData) : decData
}

/**
 * Checks if a parameter matches a certain type
 */
function isType (key, type) {
  if (typeof key === type) {
    return true
  } else {
    onError('Parameter (' + key + ') must be a ' + type)
    return false
  }
}

/**
 * Throws an error
 */
function onError (err) {
  throw new Error(err)
}

/**
 * @author <http://stackoverflow.com/a/894877/2959686>
 */
function defaultFor (arg, val) {
  return typeof arg !== 'undefined' ? arg : val
}
